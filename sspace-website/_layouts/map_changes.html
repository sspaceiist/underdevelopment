<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ title }}</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
        integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <script src="https://unpkg.com/satellite.js/dist/satellite.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">

</head>

<style>
    @font-face {
    font-family: "Technology";
    src: url("fonts/Technology.ttf") format("truetype");
  }
  @font-face {
    font-family: "Roblox";
    src: url("fonts/Roblox-Font-Regular.ttf") format("truetype");
    font-weight: normal;
  }
  @font-face {
    font-family: "Roblox_b";
    src: url('fonts/Roblox-Font-Bold.ttf') format('truetype');
    font-weight: bold;
  }
    html {
        width: 100%;
        height: 100%;
    }

    body {
        margin: 0;
        width: 100%;
        height: 100%;
    }
    .image-container {
            display: flex;
            flex-wrap: wrap;
            position: absolute;
            top: 0;
            right:5px;
            gap: 10px;
            padding: 5px 5px;
            justify-content: right;
            align-items: right;
            z-index: 1000;

    }

    #map {
        width:100%;
        height: 100%;
    }
    .top-box {
            position: fixed; /* Fix the box at the top */
            top: 5px; /* Align it to the top of the viewport */
            left: 50%; /* Move the box to the center */
            transform: translateX(-50%);
            width: auto; 
            background-color: #ed8611; 
            color: white; /* White text color */
            text-align: center; /* Center the text */
            padding: 10px 10px; /* Padding around the text */
            font-size: 20px; /* Font size */
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2); /* Optional shadow for the box */
            z-index: 1000; /* Ensure it's on top of other content */
            border-radius: 5px;
        }
   
    .navbar {
        
  overflow: hidden;
  background-color: black;
  background-image: url(sspace-website\image\background.jpg) ;
  position: absolute;
  
  width: 100%;
  height:auto;
  z-index: 1000;
}

.navbar a {
   
  float: center;
  display: block;
  color: #f2f2f2;
  text-align: center;
  padding: 10px 16px;
  text-decoration: none;
  font-size: 25px;
}

.navbar img {
            height: 8%;
        }

.navbar a.active {
  background-color: #04AA6D;
  color: white;
}


.fixed-size-image {
            
           width: 40px;
            height: 40px;
            object-fit: cover;
            transition: transform 0.3s ease;   
    }
    @media (max-width: 768px) {
            .fixed-size-image {
                width: 40px; height:40px;/* Reduce logo size on smaller screens */
            }
        }
        
        
        @media (max-width: 480px) {
            .image-container{
            flex-direction: column; /* Stack logos vertically */
                justify-content: flex-start; /* Align logos at the top */
                align-items: center; /* Center logos horizontally */
            }
            .fixed-size-image {
                width: 40px; height: 40px; /* Further reduce logo size on very small screens */
            }
        }
   


    .marker-pin {
    width: 30px;
    height: 30px;
    border-radius: 50% 50% 50% 0;
    background: black;
    position: absolute;
    transform: rotate(-45deg);
    left: 50%;
    top: 50%;
    margin: -15px 0 0 -15px;
    }
    .marker-pin::after {
        content: '';
        width: 24px;
        height: 24px;
        margin: 3px 0 0 3px;
        position: absolute;
        border-radius: 50%;
        
    }
    .marker-pin-img{
        width: 28px;
    height: 28px;
    border-radius: 50% 50% 50% 0;
    background-image:url('file.png');
    position: absolute;

    left: 50%;
    top: 50%;
    margin: -15px 0 0 -15px;
    z-index:1000;

    }

    .custom-div-icon i {
    position: absolute;
    width: 22px;
    font-size: 22px;
    left: 0;
    right: 0;
    margin: 10px auto;
    text-align: center;
    }
    .show-button {
            
            position: fixed; /* Fix button in the window */
            bottom: 5px; /* 20px from the bottom */
            right: 5px; /* 20px from the right */
            width:auto;
            padding: 5px 5px; /* Button padding */
            font-size: 20px;
            font-family:Georgia, 'Times New Roman', Times, serif;
            background-color:#e38314; /* Green background */
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            z-index: 1000; /* Ensure button is on top */
            transition: all 0.8s ease;
        }
        .show-button .button-text {
            display: none; /* Hide text initially */
        }

        .show-button .button-icon {
            font-size: 24px; 
            margin-right: 4px;
             
            display: inline-block;
        }
        .show-button:hover .button-text {
            display: inline-block; 
        }

        .table-container {
            position: fixed; /* Fix the table in the window */
            bottom: 20px; /* 20px from the bottom */
            right: 10px; /* 20px from the right */
            width: auto; /* Set a fixed width for the table */
            background-color: #fff; /* White background for the table */
            border: 2px solid black; /* Border color */
            border-radius: 8px; /* Rounded corners */
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2); /* Shadow effect */
            display: none; /* Hide the table initially */
            padding: 10px;
            z-index: 1001; /* Ensure table appears above other content */
        }
        table {
            width: 100%; /* Table takes up full container width */
            border-collapse: collapse;
        }

        table, th, td {
            border: 1px solid #ddd;
        }

        th, td {
            padding: 8px;
            text-align: center;
        }
        th {
            background-color: black;
            color: white;
        }

        td {
            background-color: #f9f9f9;
        }
       
            
         @media (max-width: 768px) {
            .show-button .button-text {
                display: none; /* Hide text on small screens */
            }

            .show-button .button-icon {
                display: inline-block; /* Show only the icon */
            }

            .show-button:hover .button-text {
                display: none; /* Keep text hidden on hover for small screens */
            }
        }
        img.icon {
            filter: invert(100%) sepia(0%) saturate(0%) hue-rotate(0deg);
        }

</style>

<body>
    <div class="top-box">
        <span id="datetime" style="font-family: 'Roblox_b';"></span>
    </div>
    <div id="map"></div>
    <div class="navbar" style="bottom: 0;">
        <a style="text-align:centre;">PiLoT-G2 (GRACE)</a>
        
      </div>
      <div class="image-container">
        <img src="{{site.url}}/image/isro.png" class="fixed-size-image">
        <img src="{{site.url}}/image/IIST_LOGO.png" class="fixed-size-image">
        <img src="{{site.url}}/image/file.png" class="fixed-size-image">
        <img src="{{site.url}}/image/grace_new.png" class="fixed-size-image">

    </div>
    <button class="show-button" onclick="toggleTable()">
        <span class="button-icon">
            <img src="https://images.emojiterra.com/google/android-12l/512px/1f6f0.png" alt="Table Icon" style="height:23px;width:23px;">
        </span>
        <span class="button-text" style="padding:5px 5px;">Future Passes</span>
    </button>
    <div class="table-container" id="tableContainer">
        <table>
            <thead>
                <tr>
                <th>AOS</th>
                <th>LOS</th>
                <th>Duration</th>
                <th>Max El</th>
                <th>AOS Az</th>
                <th>LOS Az</th>
                </tr>
                
            </thead>
            <tbody id="table-body">
                
              </tbody>
        </table>
    </div>
       
</body>

<script>
    
    function getLatLongOfGRACE(tleLine1, tleLine2, date = new Date()) {
        const satrec = satellite.twoline2satrec(tleLine1, tleLine2);
        const positionAndVelocity = satellite.propagate(satrec, date);
        if (!positionAndVelocity.position) {
        throw new Error('Error calculating satellite position.');
        }
        const positionEci = positionAndVelocity.position;
        const gmst = satellite.gstime(date);
        const geodeticCoords = satellite.eciToGeodetic(positionEci, gmst);
        const latitude = satellite.degreesLat(geodeticCoords.latitude);
        const longitude = satellite.degreesLong(geodeticCoords.longitude);
        return [latitude, longitude];
    }

    function updateMarkerFromTLE(tleLine1, tleLine2, map, interval = 1000) {
    const satrec = satellite.twoline2satrec(tleLine1, tleLine2);
    const initialPosition = getLatLongOfGRACE(tleLine1, tleLine2, new Date());
    const satIcon = L.divIcon({
      className: 'custom-icon',
      html: ' <img class="icon" src="{{site.url}}/grace.svg" style="height:45px;width:45px;"alt="Icon">',
      iconSize: [24, 24],
      iconAnchor: [12, 24],
    });
    const marker = L.marker(initialPosition, {icon: satIcon}).addTo(map);
    setInterval(() => {
        try {
        const latLong = getLatLongOfGRACE(tleLine1, tleLine2, new Date());
        marker.setLatLng(latLong);
        } catch (error) {
        console.error('Error updating marker position:', error.message);
        }
    }, interval);

    return marker;
    }

    const tleLine1 = '1 62461U 24253C   25009.26173677  .00065784  00000+0  46879-3 0  9996';
    const tleLine2 = '2 62461  55.2205 209.2082 0003525 283.8702  76.1952 15.73274472  1494';
    const date = new Date();

    var map = L.map('map', { attributionControl: false }).setView([8.6254, 77.0341], 3);
    L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19,
        attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
    }).addTo(map);
    icon = L.divIcon({
        className: 'custom-div-icon',
        html: "<div style='background-image:url(file.png);' class='marker-pin'></div><div class='marker-pin-img'><img src='https://sspace-iist-old.vercel.app/static/media/logo.8a69e042.gif' style='height:30px;width:30px;'></div>",
        iconSize: [30, 42],
        iconAnchor: [15, 42]
    });
    var marker = L.marker([8.6254, 77.0341], { icon: icon }).addTo(map);
    var popup = L.popup()
        .setLatLng([8.6254, 77.0341])
        .setContent("SSPACE GRASP")
        .openOn(map);
        
    updateMarkerFromTLE(tleLine1, tleLine2, map, 1000);

    function toggleTable() {
            var tableContainer = document.getElementById('tableContainer');
            if (tableContainer.style.display === 'none' || tableContainer.style.display === '') {
                tableContainer.style.display = 'block'; // Show the table
            } else {
                tableContainer.style.display = 'none'; // Hide the table
            }
        }
        function plotSatellitePath() {
        var satrec = satellite.twoline2satrec(tleLine1, tleLine2);

        var pathCoordinates = [];
        for (var i = 0; i < 3600; i += 30) { // Calculate every 30 seconds for 1 hour
            var now = new Date();
            now.setSeconds(now.getSeconds() + i);
            
            // Get satellite position for the given time
            var positionAndVelocity = satellite.propagate(satrec, now);
            if (positionAndVelocity) {
                var positionEci = positionAndVelocity.position;

// Convert ECI (Earth Centered Inertial) to Lat/Lon
var positionGd = satellite.eciToGeodetic(positionEci, now);
var lat = positionGd.latitude * (180 / Math.PI); // Convert radians to degrees
var lon = positionGd.longitude * (180 / Math.PI); // Convert radians to degrees

pathCoordinates.push([lat, lon]); // Add to path coordinates array
}
}

// Plot the satellite path on the map
L.polyline(pathCoordinates, { color: 'red' }).addTo(map); // Draw the satellite path
}
    function updateDateTime() {
        
        const now = new Date();

        
        const currentDateTime = now.toLocaleString();

        
        document.querySelector('#datetime').textContent = currentDateTime;
      }
      setInterval(updateDateTime, 1000);

      function getSatellitePasses(tleLine1, tleLine2, observerLat, observerLong) {
        const satrec = satellite.twoline2satrec(tleLine1, tleLine2); // Convert TLE to satellite record
        const now = new Date();
        const endTime = new Date(now.getTime() + 3 * 24 * 60 * 60 * 1000); // 3 days from now
        const passes = [];
        let currentPass = null;

        // Loop over each hour in the 3-day window
        for (let time = new Date(now); time <= endTime; time.setHours(time.getHours() + 1)) {
            try {
                // Get satellite position for the current time
                const positionAndVelocity = satellite.propagate(satrec, time);
                const position = positionAndVelocity.position;

                // Convert position from ECI to geodetic coordinates
                const geodetic = satellite.eciToGeodetic(position, time);
                const satLat = geodetic.latitude;
                const satLon = geodetic.longitude;

                // Calculate range (distance) between observer and satellite (in radians)
                const range = satellite.greatCircleDistance(observerLat, observerLong, satLat, satLon);
                const elevation = Math.asin(Math.sin(range) * Math.sin(observerLat - satLat)); // Elevation angle

                // Calculate azimuth
                const deltaLon = satLon - observerLong;
                const x = Math.cos(satLat) * Math.sin(deltaLon);
                const y = Math.cos(observerLat) * Math.sin(satLat) - Math.sin(observerLat) * Math.cos(satLat) * Math.cos(deltaLon);
                let azimuth = Math.atan2(x, y) * 180 / Math.PI; // Azimuth in degrees

                // Adjust azimuth to be between 0 and 360
                if (azimuth < 0) {
                    azimuth += 360;
                }

                // If the satellite is above the horizon (elevation > 0), check if it's AOS or LOS
                if (elevation > 0) {
                    // If no current pass, start a new one for AOS
                    if (!currentPass) {
                        currentPass = {
                            aosTime: new Date(time),
                            maxElevation: elevation,
                            aosAzimuth: azimuth
                        };
                    } else {
                        // Update max elevation during the pass
                        if (elevation > currentPass.maxElevation) {
                            currentPass.maxElevation = elevation;
                        }
                        // Update azimuth
                        currentPass.aosAzimuth = azimuth;
                    }
                } else if (currentPass) {
                    // If the satellite is below the horizon (elevation <= 0) and we have a current pass, set the LOS
                    currentPass.losTime = new Date(time);
                    currentPass.losAzimuth = azimuth;
                    // Calculate duration and add the result as a tuple to the passes array
                    const duration = (currentPass.losTime - currentPass.aosTime) / 1000; // Duration in seconds
                    passes.push([
                        currentPass.aosTime.toLocaleString(),  // AOS time
                        currentPass.losTime.toLocaleString(),  // LOS time
                        duration,                               // Duration in seconds
                        currentPass.maxElevation,              // Max Elevation
                        currentPass.aosAzimuth,                // AOS Azimuth
                        currentPass.losAzimuth                 // LOS Azimuth
                    ]);
                    currentPass = null; // Reset for the next pass
                }
            } catch (error) {
                console.error('Error calculating satellite pass details:', error.message);
            }
        }

        console.log(passes);  // Log the passes to the console
        return passes;        // Return the list of passes as tuples
    }
    function displayTuples() {
      const tuples = getSatellitePasses(); // Get the tuples
      const tableBody = document.getElementById("table-body"); // Get the <tbody> element

      // Loop through the tuples and create a row for each one
      tuples.forEach(function(tuple) {
        const row = document.createElement("tr"); // Create a new row

        // Loop through each value in the tuple
        tuple.forEach(function(item) {
          const cell = document.createElement("td"); // Create a new cell
          cell.textContent = item; // Set the text content of the cell to the item
          row.appendChild(cell); // Append the cell to the row
        });

        tableBody.appendChild(row); // Append the row to the table body
      });
    }

// Call the function to display the tuples when the page loads
displayTuples();
</script>

</html>